Identifying the Shell in use:
```bash 
ps -p $$
```
Use this command to identify the shell you are currently operating in.
`ps` => return list of processes
`-p` => process ID
`$$` => current process, namely the shell you are currently using.

```bash 
$ ps -p $$
    PID TTY          TIME CMD
   1217 pts/0    00:00:00 zsh
```
```bash 
function localmessage {
local MESSAGE="inside"
echo $MESSAGE
}
```
**"local"** keyword here indicates that the variable **'MESSAGE'** is local to the function. If we do not use the local keyword, then **'MESSAGE'** variable will still be "inside" even after we exit from the function.

# Argvs in shell
`$0` => the name of the script
`$1` => first argv
`$#` => number of arguments we have
`./myscript.sh batu` => batu is the argv1 = $1

Variables in bash are always in the format:

`VARNAME=VALUE`

You should not put spaces in between there. 

# Building a TCP port scanner in bash
```bash 
#!/bin/bash
host=$1
start=$2
end=$3

function pingcheck {
	ping -c 1 -w 1 "$host" &> /dev/null && echo "host is UP" || echo "host is DOWN"
}
function portcheck {
	for ((counter=$start; counter<=$end; counter++))
	do
		(echo >/dev/tcp/"$host"/"$counter") > /dev/null 2>&1 && echo "port $counter is OPEN" || echo "port $counter is CLOSED"
	done
}

pingcheck
portcheck

```

# Windows PowerShell (Batch (.bat)) Scripting
every variable starts with **$**

`$myvariable = 123`

calling it:
`$myvariable` ====> returns 123

# PowerShell Ping Scanner

```powershell $devices = @("google.com","twitter.com")
foreach ($device in $devices)
{
	write-output "device is, " $device
	$ping = New-Object System.Net.NetworkInformation.Ping
	$result = $ping.Send($device)
	$result
}
```
@ indicates an array in the first line
save the file as anything.PS1 with the extension powershell **"PS1"**
` System.Net.NetworkInformation.Ping` comes from Microsoft .NET library

# PowerShell Port Scanner
```powershell
$device = $args[0]
$port = $args[1]
$start = $args[2]
$stop = $args[3]

function pingdevice{
	if(test-connection $device -erroraction silentlycontinue){
		write-output "$device is UP"
	}else{
		write-output "$device is DOWN"
		exit
	}
}

function checkports{
	if ($port -match "multi"){
		for ($counter=$start; $counter -le $stop; $counter++) 
		{
			write-output "testing port $counter on $device"
			$porttest = new-object Net.Sockets.TcpClient
			try{
				$connect = $porttest.connect($device,$counter)
				write-output "port $counter is OPEN"
			}catch{
				write-output "port $counter is CLOSED"
			}
		}

	}else{
		write-output "testing port $counter on $device"
		$porttest = new-object Net.Sockets.TcpClient
		try{
			$connect = $porttest.connect($device,$port)
			write-output "port $port is OPEN"
		}catch{
			write-output "port $port is CLOSED"
		}
	}
}

pingdevice
checkports
```

# Output
```powershell
PS C:\Users\batu\Desktop> .\test.PS1 google.com 443
google.com is UP
testing port  on google.com
port 443 is OPEN
PS C:\Users\batu\Desktop> .\test.PS1 google.com 444
google.com is UP
testing port  on google.com
port 444 is CLOSED
```