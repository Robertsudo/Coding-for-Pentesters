The **Motto** of the Perl language: "There is more than one way to do it (multiple ways to do the same thing.)"

Perl is just a tool to handle and manipulate raw **text data** (like sed and awk)

Goal: Build an SNMP scanner using perl language (SNMP = simple network management protocol)

in perl every "statement" (NOT LINE) ends with `; (semicolon)`
variables are always addressed with `$`
```perl
#!/usr/bin/perl
print "what is your name?\n";
$name = <STDIN>; # take input from standard input
chomp $name; # or chop, cut \n (newline) part that is added when we pressed "ENTER"
print "Hello,$name\n"

sub myFunction {
#code here => like function myFunction in R
}

# @ indicates array (list)
# example => @ARGV[0] = name of the script @ARGV[1] = first arg ...
# NOPE!
# @ARGV[0] does not store the name of script, instead it stores first arg

# using modules
# import something (python) <========> use somelibrary::something; (perl)
```
# Regex

```perl
#!/usr/bin/perl
$text = `ifconfig | grep ether`;
print "the full-line is => ",$text,"\n";
$text =~ m/((?:[0-9a-f]{2}[:-]){5}[0-9a-f]{2})/i;
print "the mac address is => ",$&,"\n"; # $& is the previous successful match against regex.
```
Remember every "statement" ends with `;`
We use The backquote (backtick) operator to run bash commands under perl.
`=~` => regex with tilda/tilde ~
`\m` => match operator (at the beginning)
`\i` => case-insensitive (at the end)
Summary => find me something  2 characters long that is composed of 0-9 or a-f followed by a colon.
repeat 5 times. at the final two characters, remove colon :.
```bash
the full-line is =>         ether 00:00:00:00:00:00  txqueuelen 1000  (Ethernet)

the mac address is => 00:00:00:00:00:00
```
# SNMP Scanner with Perl
source: https://github.com/rohythakur/SNMP-scanner-with-perl/blob/master/SNMPscanner.pl
```perl
#!/usr/bin/perl
#rohyt
use Net::Ping;
use Net::SNMP;
@log; #array that holds the log
$time = localtime;
push (@log,"\n\n###### $time ######\n\n");
#variables for ping
$ip1 = @ARGV[0];
$ip2 = @ARGV[1];
$rawip1 = get_raw_address($ip1);
$rawip2 = get_raw_address($ip2);
#variables for SNMP
$mibName = "1.3.6.1.2.1.1.5.0"; # System Name
$mibDescr = "1.3.6.1.2.1.1.1.0"; # System Description
$mibHardwareType = "1.3.6.1.2.1.25.3.2.1.2.1"; # hardware type
$port = 161;
$community = "public";
$retries = 1;
#main loop
for ($counter = $rawip1;$counter<= $rawip2;$counter++){
$host = get_ip_address($counter);
$pinger = Net::Ping->new("icmp", 1, 64);
if ($pinger->ping($host)) {
print "\n$host is up\n";
push (@log,"\n$host is up");
&init_snmp;
&get_snmp_info;
$session->close;
&write_log;
} else {
print "\n$host is down\n";
push (@log,"\n$host is down");
&write_log;
}
}
###### get_raw_address ######
#get the raw version of an IP
sub get_raw_address {
my $ipaddress;
my $oct1;
my $oct2;
my $oct3;
my $oct4;
my $retval;
$ipaddress = shift;
($oct1, $oct2, $oct3, $oct4) = split /\./, $ipaddress;
$retval = $oct4 + ($oct3 * 2**8) + ($oct2 * 2**16) + ($oct1 * 2**24);
return $retval;
}
###### get_ip_address ########
#get the regular version of an IP
sub get_ip_address {
my $rawaddress;
my $retval;
my $oct;
my $counter;
$rawaddress = shift;
while ($counter<4){
$oct = $rawaddress % 2**8; #get the rightmost 8 bits
$retval = $oct . "." . $retval;
$rawaddress = int($rawaddress / 2**8); #get the next 8 bits
$counter++;
}
chop $retval;
if ($retval =~ m/\.(255 | 0)$/) { # skip 0 & 255 addresses
return 0;
}
return $retval;
}
###### init_snmp ######
#set up an SNMP session
sub init_snmp {
($session, $error) = Net::SNMP->session(
Hostname => $host,
Community => $community,
Port => $port,
Retries => $retries
);
if(!defined($session)){
die "Couldn't setup SNMP session\n\n"
}
$session->timeout($timeout);
}
###### get_snmp_info ######
#retrieve our specified information
sub get_snmp_info{
$name = &get_request($mibName);
if ($name =~ /no response/){
print "no SNMP response from ",$host,"\n";
return;
}
print "name = ",$name,"\n";
push (@log,"name = $name");
$description = &get_request($mibDescr);
print "description = ",$description,"\n";
push (@log,"description = $description");
$hardware = &get_request($mibHardwareType);
if ($hardware =~ /1.3.6.1.2.1.25.3.1.5/){
$hardware = "Printer";
}
if ($hardware =~ /1.3.6.1.2.1.25.3.1.3/){
$hardware = "Processor";
}
if ($hardware =~ /1.3.6.1.2.1.25.3.1.4/){
$hardware = "Network";
}
if ($hardware =~ /1.3.6.1.2.1.25.3.1.6/){
$hardware = "Disk Storage";
}
if ($hardware =~ //){
$hardware = "Unknown";
}
print "hardware = ",$hardware,"\n";
push (@log,"hardware = $hardware");
}
###### get_request ######
#grab a specific MIB
sub get_request {
# Takes only one MIB as an argument!
my $response;
my $return;
if(!defined($response = $session->get_request($_[0]))) {
return "no response";
}
$return = $response->{$_[0]};
return $return;
}
###### write log ######
#write out all the log entries in @log
sub write_log{
open (LOG, ">>snmp.log") || print "Error Opening snmplog.log: $!\n";
print LOG join("\n",@log), "\n";
close(LOG) or die "Error Closing snmplog.log : $!\n";
@log = (); #clear the log array
}
```